--- origsrc/oneTBB-2021.4.0/CMakeLists.txt	2021-10-04 18:50:18.000000000 +0900
+++ src/oneTBB-2021.4.0/CMakeLists.txt	2021-10-05 21:10:32.848792200 +0900
@@ -226,9 +226,11 @@ else()
             DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/${PROJECT_NAME}
             COMPONENT devel)
 
-    install(FILES "README.md"
-            DESTINATION ${CMAKE_INSTALL_DOCDIR}
-            COMPONENT devel)
+    if (NOT CYGWIN)
+        install(FILES "README.md"
+                DESTINATION ${CMAKE_INSTALL_DOCDIR}
+                COMPONENT devel)
+    endif()
     # -------------------------------------------------------------------
 endif()
 
--- origsrc/oneTBB-2021.4.0/include/oneapi/tbb/detail/_config.h	2021-10-04 18:50:18.000000000 +0900
+++ src/oneTBB-2021.4.0/include/oneapi/tbb/detail/_config.h	2021-10-05 15:43:49.203640800 +0900
@@ -195,7 +195,7 @@
 
 /** __TBB_WEAK_SYMBOLS_PRESENT denotes that the system supports the weak symbol mechanism **/
 #ifndef __TBB_WEAK_SYMBOLS_PRESENT
-    #define __TBB_WEAK_SYMBOLS_PRESENT ( !_WIN32 && !__APPLE__ && !__sun && (__TBB_GCC_VERSION >= 40000 || __INTEL_COMPILER ) )
+    #define __TBB_WEAK_SYMBOLS_PRESENT ( !_WIN32 && !__APPLE__ && !__sun && (__TBB_GCC_VERSION >= 40000 || __INTEL_COMPILER ) && !__CYGWIN__)
 #endif
 
 /** Presence of compiler features **/
--- origsrc/oneTBB-2021.4.0/src/tbbbind/tbb_bind.cpp	2021-10-04 18:50:18.000000000 +0900
+++ src/oneTBB-2021.4.0/src/tbbbind/tbb_bind.cpp	2021-10-05 15:46:55.639914300 +0900
@@ -405,7 +405,7 @@ class binding_handler {
     affinity_masks_container affinity_backup;
     system_topology::affinity_mask handler_affinity_mask;
 
-#if WIN32
+#if defined(WIN32)
     affinity_masks_container affinity_buffer;
     int my_numa_node_id;
     int my_core_type_id;
@@ -415,7 +415,7 @@ class binding_handler {
 public:
     binding_handler( std::size_t size, int numa_node_id, int core_type_id, int max_threads_per_core )
         : affinity_backup(size)
-#if WIN32
+#if defined(WIN32)
         , affinity_buffer(size)
         , my_numa_node_id(numa_node_id)
         , my_core_type_id(core_type_id)
@@ -424,7 +424,7 @@ public:
     {
         for (std::size_t i = 0; i < size; ++i) {
             affinity_backup[i] = system_topology::instance().allocate_process_affinity_mask();
-#if WIN32
+#if defined(WIN32)
             affinity_buffer[i] = system_topology::instance().allocate_process_affinity_mask();
 #endif
         }
@@ -436,7 +436,7 @@ public:
     ~binding_handler() {
         for (std::size_t i = 0; i < affinity_backup.size(); ++i) {
             system_topology::instance().free_affinity_mask(affinity_backup[i]);
-#if WIN32
+#if defined(WIN32)
             system_topology::instance().free_affinity_mask(affinity_buffer[i]);
 #endif
         }
@@ -452,7 +452,7 @@ public:
 
         topology.store_current_affinity_mask(affinity_backup[slot_num]);
 
-#if WIN32
+#if defined(WIN32)
         // TBBBind supports only systems where NUMA nodes and core types do not cross the border
         // between several processor groups. So if a certain NUMA node or core type constraint
         // specified, then the constraints affinity mask will not cross the processor groups' border.
--- origsrc/oneTBB-2021.4.0/test/common/common_arena_constraints.h	2021-10-04 18:50:18.000000000 +0900
+++ src/oneTBB-2021.4.0/test/common/common_arena_constraints.h	2021-10-05 19:18:51.424917200 +0900
@@ -88,7 +88,7 @@ int get_processors_group_count() { retur
 #define __HWLOC_TOPOLOGY_FLAG_RESTRICT_TO_CPUBINDING_PRESENT (HWLOC_API_VERSION >= 0x20500)
 // At this moment the hybrid CPUs HWLOC interfaces returns unexpected results on some Windows machines
 // in the 32-bit arch mode.
-#define __HWLOC_HYBRID_CPUS_INTERFACES_VALID (!_WIN32 || _WIN64)
+#define __HWLOC_HYBRID_CPUS_INTERFACES_VALID (!_WIN32)
 
 #define __HYBRID_CPUS_TESTING __HWLOC_HYBRID_CPUS_INTERFACES_PRESENT && __HWLOC_HYBRID_CPUS_INTERFACES_VALID
 
--- origsrc/oneTBB-2021.4.0/test/tbb/test_eh_thread.cpp	2021-10-04 18:50:18.000000000 +0900
+++ src/oneTBB-2021.4.0/test/tbb/test_eh_thread.cpp	2021-10-05 16:40:25.779943800 +0900
@@ -34,7 +34,7 @@
 // On Windows there is no real thread number limit beside available memory.
 // Therefore, the test for thread limit is unreasonable.
 // TODO: enable limitThreads with sanitizer under docker
-#if TBB_USE_EXCEPTIONS && !_WIN32 && !__ANDROID__
+#if TBB_USE_EXCEPTIONS && !_WIN32 && !__ANDROID__ && !defined(__CYGWIN__)
 
 #include <sys/types.h>
 #include <sys/time.h>
